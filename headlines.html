<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Headlines Rev5</title>

<style>
/* =========================================================
   Headlines ticker Rev4
   Goal: stop "No headlines available" by being much more robust.
   ========================================================= */

/* Visual controls */
:root{
  --fontSize: 46px;     /* headline font size */
  --sourceSize: 30px;   /* source label font size */
  --gap: 30px;          /* spacing between items */
  --dotSize: 8px;       /* dot size */
  --padX: 14px;         /* left/right padding */
}

html, body {
  margin: 0;
  padding: 0;
  width: 100%;
  height: 100%;
  background: #000;
  overflow: hidden;
  font-family: Arial, sans-serif;
}

.bar {
  height: 100%;
  width: 100%;
  display: flex;
  align-items: center;
  background: #000;
  color: #fff;
}

.track {
  position: relative;
  flex: 1 1 auto;
  height: 100%;
  overflow: hidden;
  padding: 0 var(--padX);
  box-sizing: border-box;
}

/* Scrolling content container */
.marquee {
  position: absolute;
  white-space: nowrap;
  will-change: transform;
  line-height: 1;
  display: inline-flex;
  align-items: center;
  gap: var(--gap);
  padding-left: 100%;
}

.item {
  display: inline-flex;
  align-items: center;
  gap: 12px;
}

.dot {
  width: var(--dotSize);
  height: var(--dotSize);
  border-radius: 50%;
  background: #1f6feb;
  flex: 0 0 auto;
}

.source {
  color: #cdd5df;
  font-weight: 800;
  font-size: var(--sourceSize);
}

.title {
  color: #ffffff;
  font-weight: 650;
  font-size: var(--fontSize);
}

/* Status overlay (loading, errors, debug) */
.status {
  position: absolute;
  inset: 0;
  display: none;
  align-items: center;
  padding: 0 var(--padX);
  color: #f0f0f0;
  font-size: calc(var(--fontSize) - 12px);
}

a { color: inherit; text-decoration: none; }
</style>
</head>

<body>
<div class="bar">
  <div class="track">
    <div id="status" class="status">Loading...</div>
    <div id="marquee" class="marquee"></div>
  </div>
</div>

<script>
/* =========================================================
   Rev4 approach
   =========================================================
   In wallboards, RSS fetch failures are usually:
   - CORS blocks the feed directly
   - A proxy is down or rate-limiting
   - Proxy returns HTML wrapper, not raw XML
   - Feed is Atom, not RSS

   Fixes in Rev4:
   1) Tries direct fetch first (some feeds allow it)
   2) Tries multiple proxies (not just AllOrigins)
   3) Extracts XML out of HTML-wrapped proxy responses
   4) Parses both RSS (<item>) and Atom (<entry>)
   5) Shows a helpful debug status if all feeds fail
   6) Uses cached last-good headlines as fallback
*/

/* -----------------------------
   Tuning
   ----------------------------- */
const SPEED_PX_PER_SEC = 70;
const MAX_ITEMS = 12;
const REFRESH_MINUTES = 10;

/* Turn this on to see which feeds/proxies are failing in the status line */
const DEBUG = true;

/* -----------------------------
   Feeds
   Keep a few. Any one can break.
   ----------------------------- */
const FEEDS = [
  { name: "BBC",        url: "https://feeds.bbci.co.uk/news/rss.xml" },
  { name: "NPR",        url: "https://feeds.npr.org/1001/rss.xml" },
  { name: "Guardian",   url: "https://www.theguardian.com/world/rss" },
  { name: "Al Jazeera", url: "https://www.aljazeera.com/xml/rss/all.xml" },
  { name: "AP",         url: "https://apnews.com/hub/ap-top-news?output=rss" }
];

/* Cache key (last-known-good headlines) */
const CACHE_KEY = "headlines_rev4_cache_v1";

/* DOM refs */
const statusEl = document.getElementById("status");
const marqueeEl = document.getElementById("marquee");

/* Status helpers */
function showStatus(msg) {
  statusEl.style.display = "flex";
  statusEl.textContent = msg;
}
function hideStatus() {
  statusEl.style.display = "none";
}

/* -----------------------------
   Proxy builders
   Each returns a full URL to request.
   ----------------------------- */
function proxyCandidates(originalUrl) {
  const u = encodeURIComponent(originalUrl);

  return [
    /* Direct attempt first */
    originalUrl,

    /* Codetabs proxy */
    "https://api.codetabs.com/v1/proxy?quest=" + u,

    /* Freeboard thingproxy */
    "https://thingproxy.freeboard.io/fetch/" + originalUrl,

    /* AllOrigins raw */
    "https://api.allorigins.win/raw?url=" + u
  ];
}

/* -----------------------------
   Fetch with timeout
   ----------------------------- */
async function fetchText(url, timeoutMs) {
  const controller = new AbortController();
  const t = setTimeout(() => controller.abort(), timeoutMs);
  try {
    const res = await fetch(url, { cache: "no-store", signal: controller.signal });
    if (!res.ok) throw new Error("HTTP " + res.status);
    return await res.text();
  } finally {
    clearTimeout(t);
  }
}

/* -----------------------------
   Some proxies return HTML wrappers.
   This extracts the XML portion if it exists.
   ----------------------------- */
function extractXmlMaybe(text) {
  const lower = text.toLowerCase();

  /* Find RSS or Atom start */
  const rssStart = lower.indexOf("<rss");
  const feedStart = lower.indexOf("<feed");
  let start = -1;
  let endTag = "";

  if (rssStart !== -1 && (feedStart === -1 || rssStart < feedStart)) {
    start = rssStart;
    endTag = "</rss>";
  } else if (feedStart !== -1) {
    start = feedStart;
    endTag = "</feed>";
  }

  if (start === -1) return "";

  const end = lower.lastIndexOf(endTag);
  if (end === -1) return text.slice(start);

  return text.slice(start, end + endTag.length);
}

/* -----------------------------
   Parse RSS and Atom
   Output: [{title, link, pubDate, source}]
   ----------------------------- */
function parseFeedXml(xmlText, sourceName) {
  const doc = new DOMParser().parseFromString(xmlText, "text/xml");
  if (doc.querySelector("parsererror")) return [];

  const out = [];

  /* RSS */
  const items = Array.from(doc.querySelectorAll("item"));
  for (const it of items) {
    const title = (it.querySelector("title")?.textContent || "").trim();

    let link = (it.querySelector("link")?.textContent || "").trim();
    if (!link) {
      const guid = it.querySelector("guid");
      const isPermalink = (guid?.getAttribute("isPermaLink") || "").toLowerCase() === "true";
      if (isPermalink) link = (guid?.textContent || "").trim();
    }

    const pubDate =
      (it.querySelector("pubDate")?.textContent || "").trim() ||
      (it.querySelector("dc\\:date")?.textContent || "").trim() ||
      "";

    if (title && link) out.push({ title, link, pubDate, source: sourceName });
  }

  /* Atom */
  const entries = Array.from(doc.querySelectorAll("entry"));
  for (const e of entries) {
    const title = (e.querySelector("title")?.textContent || "").trim();

    let link = "";
    const linkEl = e.querySelector('link[rel="alternate"]') || e.querySelector("link");
    if (linkEl) link = (linkEl.getAttribute("href") || "").trim();

    const pubDate =
      (e.querySelector("updated")?.textContent || "").trim() ||
      (e.querySelector("published")?.textContent || "").trim() ||
      "";

    if (title && link) out.push({ title, link, pubDate, source: sourceName });
  }

  return out;
}

/* -----------------------------
   Dedupe and sorting helpers
   ----------------------------- */
function normalizeTitle(t) {
  return t.toLowerCase().replace(/\s+/g, " ").replace(/[“”"']/g, "").trim();
}
function dedupe(items) {
  const seen = new Set();
  const out = [];
  for (const it of items) {
    const key = normalizeTitle(it.title);
    if (seen.has(key)) continue;
    seen.add(key);
    out.push(it);
  }
  return out;
}
function safeTime(s) {
  const t = Date.parse(s);
  return Number.isFinite(t) ? t : 0;
}

/* -----------------------------
   Build the marquee DOM
   - Creates one run of items then appends a clone for seamless looping.
   ----------------------------- */
function buildMarquee(items) {
  marqueeEl.innerHTML = "";

  for (const h of items) {
    const span = document.createElement("span");
    span.className = "item";

    const dot = document.createElement("span");
    dot.className = "dot";

    const src = document.createElement("span");
    src.className = "source";
    src.textContent = h.source;

    const a = document.createElement("a");
    a.href = h.link;

    /* Do not navigate the iframe page away */
    a.target = "_blank";
    a.rel = "noopener noreferrer";

    const title = document.createElement("span");
    title.className = "title";
    title.textContent = h.title;

    a.appendChild(title);
    span.appendChild(dot);
    span.appendChild(src);
    span.appendChild(a);

    marqueeEl.appendChild(span);
  }

  const clone = marqueeEl.cloneNode(true);
  clone.id = "";
  marqueeEl.appendChild(clone);
}

/* -----------------------------
   Scroll animation
   ----------------------------- */
let animId = null;
let x = 0;
let lastTs = null;

function startScroll() {
  if (animId) cancelAnimationFrame(animId);
  x = 0;
  lastTs = null;

  function step(ts) {
    if (lastTs == null) lastTs = ts;
    const dt = (ts - lastTs) / 1000;
    lastTs = ts;

    x -= SPEED_PX_PER_SEC * dt;

    const cycleWidth = marqueeEl.scrollWidth / 2;
    if (cycleWidth > 0 && Math.abs(x) >= cycleWidth) x = 0;

    marqueeEl.style.transform = "translateX(" + x + "px)";
    animId = requestAnimationFrame(step);
  }

  animId = requestAnimationFrame(step);
}

/* -----------------------------
   Cache helpers
   ----------------------------- */
function saveCache(items) {
  try {
    localStorage.setItem(CACHE_KEY, JSON.stringify({ ts: Date.now(), items }));
  } catch (e) {}
}
function loadCache() {
  try {
    const raw = localStorage.getItem(CACHE_KEY);
    if (!raw) return null;
    const obj = JSON.parse(raw);
    if (!obj || !Array.isArray(obj.items)) return null;
    return obj.items;
  } catch (e) {
    return null;
  }
}

/* -----------------------------
   Fetch one feed using multiple candidates
   Returns { items, errors } so we can debug.
   ----------------------------- */
async function fetchFeed(feed) {
  const candidates = proxyCandidates(feed.url);
  const errors = [];

  for (const u of candidates) {
    try {
      const text = await fetchText(u, 9000);

      /* Pull XML out if the proxy added wrapper text */
      const xml = extractXmlMaybe(text) || text;

      const items = parseFeedXml(xml, feed.name);
      if (items.length) return { items, errors };

      errors.push(feed.name + " parse-empty via " + short(u));
    } catch (e) {
      errors.push(feed.name + " " + String(e.message || e) + " via " + short(u));
    }
  }

  return { items: [], errors };
}

function short(u) {
  try {
    const url = new URL(u);
    return url.host;
  } catch (e) {
    return "url";
  }
}

/* -----------------------------
   Main refresh
   ----------------------------- */
async function refresh() {
  showStatus("Loading headlines...");

  const results = await Promise.allSettled(FEEDS.map(fetchFeed));

  let items = [];
  let errors = [];

  for (const r of results) {
    if (r.status === "fulfilled") {
      items = items.concat(r.value.items);
      errors = errors.concat(r.value.errors);
    }
  }

  items = dedupe(items);
  items.sort((a, b) => safeTime(b.pubDate) - safeTime(a.pubDate));
  items = items.slice(0, MAX_ITEMS);

  /* If nothing loaded, use cache, else show debug errors */
  if (!items.length) {
    const cached = loadCache();
    if (cached && cached.length) {
      buildMarquee(cached);
      startScroll();
      showStatus("Using cached headlines");
      return;
    }

    if (DEBUG && errors.length) {
      showStatus("No headlines. Last errors: " + errors.slice(0, 3).join(" | "));
    } else {
      showStatus("No headlines available");
    }
    return;
  }

  hideStatus();
  buildMarquee(items);
  startScroll();
  saveCache(items);
}

/* Start now and refresh periodically */
refresh();
setInterval(refresh, REFRESH_MINUTES * 60 * 1000);
</script>
</body>
</html>

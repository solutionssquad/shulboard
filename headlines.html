<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Headlines Rev9</title>

<style>
:root{
  --fontSize: 38px;
  --sourceSize: 28px;
  --timeSize: 14px;     /* NEW: small timestamp under source */
  --gap: 30px;
  --dotSize: 8px;
  --padX: 14px;
}

html, body {
  margin: 0;
  padding: 0;
  width: 100%;
  height: 100%;
  background: #000;
  overflow: hidden;
  font-family: Arial, sans-serif;
}

.bar {
  height: 100%;
  width: 100%;
  display: flex;
  align-items: center;
  background: #000;
  color: #fff;
}

.track {
  position: relative;
  flex: 1 1 auto;
  height: 100%;
  display: flex;
  align-items: center;
  overflow: hidden;
  padding: 0 var(--padX);
  box-sizing: border-box;
}

.marquee {
  position: absolute;
  left: 0;
  white-space: nowrap;
  will-change: transform;
  display: inline-flex;
  align-items: center;
  gap: var(--gap);
  padding-left: 100%;
}

.item {
  display: inline-flex;
  align-items: center;
  gap: 12px;
}

.dot {
  width: var(--dotSize);
  height: var(--dotSize);
  border-radius: 50%;
  background: #1f6feb;
  flex: 0 0 auto;
}

/* Source + time stacked vertically */
.sourceBlock {
  display: flex;
  flex-direction: column;
  line-height: 1;
  margin-right: 6px;
}

.source {
  color: #cdd5df;
  font-weight: 800;
  font-size: var(--sourceSize);
  line-height: 1;
}

.time {
  color: #7f8a96;
  font-weight: 650;
  font-size: var(--timeSize);
  line-height: 1;
  margin-top: 2px;
}

.title {
  color: #ffffff;
  font-weight: 650;
  font-size: var(--fontSize);
}

.status {
  position: absolute;
  inset: 0;
  display: none;
  align-items: center;
  justify-content: flex-start;
  padding: 0 var(--padX);
  color: #f0f0f0;
  font-size: calc(var(--fontSize) - 12px);
}

a { color: inherit; text-decoration: none; }
</style>
</head>

<body>
<div class="bar">
  <div class="track">
    <div id="status" class="status">Loading...</div>
    <div id="marquee" class="marquee"></div>
  </div>
</div>

<script>
/* =========================================================
   Headlines wallboard ticker
   - Per feed: take latest 3 items
   - Timestamp under source: "Thu 15:07" (day-of-week + 24h time)
   ========================================================= */

/* Tuning */
const SPEED_PX_PER_SEC = 65;
const PER_FEED_MAX = 3;
const MAX_ITEMS = 40;          // safety cap after merge
const REFRESH_MINUTES = 5;
const DEBUG = false;

/* Feeds */
const FEEDS = [
  { name: "Political Wire",        url: "https://politicalwire.com/feed/" },
  /* { name: "BBC",        url: "https://feeds.bbci.co.uk/news/rss.xml" }, */
  { name: "NBC News",        url: "https://feeds.nbcnews.com/nbcnews/public/news" },
  { name: "YWN",   url: "https://www.theyeshivaworld.com/article.php/feed" },
  { name: "Middle East Eye", url: "https://feeder.co/discover/5c9c89be31/middleeasteye-net-rss" },
  { name: "IRNA",         url: "https://en.irna.ir/rss" },
  { name: "AP",         url: "https://apnews.com/hub/ap-top-news?output=rss" }  
];

/* Cache key */
const CACHE_KEY = "headlines_rev9_cache_v1";

/* DOM refs */
const statusEl = document.getElementById("status");
const marqueeEl = document.getElementById("marquee");

/* Status helpers */
function showStatus(msg) {
  statusEl.style.display = "flex";
  statusEl.textContent = msg;
}
function hideStatus() {
  statusEl.style.display = "none";
}

/* Proxy candidates */
function proxyCandidates(originalUrl) {
  const u = encodeURIComponent(originalUrl);
  return [
    originalUrl,
    "https://api.codetabs.com/v1/proxy?quest=" + u,
    "https://thingproxy.freeboard.io/fetch/" + originalUrl,
    "https://api.allorigins.win/raw?url=" + u
  ];
}

/* Fetch with timeout */
async function fetchText(url, timeoutMs) {
  const controller = new AbortController();
  const t = setTimeout(() => controller.abort(), timeoutMs);
  try {
    const res = await fetch(url, { cache: "no-store", signal: controller.signal });
    if (!res.ok) throw new Error("HTTP " + res.status);
    return await res.text();
  } finally {
    clearTimeout(t);
  }
}

/* Extract XML from wrapper pages */
function extractXmlMaybe(text) {
  const lower = text.toLowerCase();
  const rssStart = lower.indexOf("<rss");
  const feedStart = lower.indexOf("<feed");
  let start = -1;
  let endTag = "";

  if (rssStart !== -1 && (feedStart === -1 || rssStart < feedStart)) {
    start = rssStart;
    endTag = "</rss>";
  } else if (feedStart !== -1) {
    start = feedStart;
    endTag = "</feed>";
  }

  if (start === -1) return "";
  const end = lower.lastIndexOf(endTag);
  if (end === -1) return text.slice(start);
  return text.slice(start, end + endTag.length);
}

/* Parse RSS + Atom */
function parseFeedXml(xmlText, sourceName) {
  const doc = new DOMParser().parseFromString(xmlText, "text/xml");
  if (doc.querySelector("parsererror")) return [];

  const out = [];

  /* RSS */
  const items = Array.from(doc.querySelectorAll("item"));
  for (const it of items) {
    const title = (it.querySelector("title")?.textContent || "").trim();

    let link = (it.querySelector("link")?.textContent || "").trim();
    if (!link) {
      const guid = it.querySelector("guid");
      const isPermalink = (guid?.getAttribute("isPermaLink") || "").toLowerCase() === "true";
      if (isPermalink) link = (guid?.textContent || "").trim();
    }

    const pubDate =
      (it.querySelector("pubDate")?.textContent || "").trim() ||
      (it.querySelector("dc\\:date")?.textContent || "").trim() ||
      "";

    if (title && link) out.push({ title, link, pubDate, source: sourceName });
  }

  /* Atom */
  const entries = Array.from(doc.querySelectorAll("entry"));
  for (const e of entries) {
    const title = (e.querySelector("title")?.textContent || "").trim();

    let link = "";
    const linkEl = e.querySelector('link[rel="alternate"]') || e.querySelector("link");
    if (linkEl) link = (linkEl.getAttribute("href") || "").trim();

    const pubDate =
      (e.querySelector("updated")?.textContent || "").trim() ||
      (e.querySelector("published")?.textContent || "").trim() ||
      "";

    if (title && link) out.push({ title, link, pubDate, source: sourceName });
  }

  return out;
}

/* Helpers */
function normalizeTitle(t) {
  return t.toLowerCase().replace(/\s+/g, " ").replace(/[“”"']/g, "").trim();
}
function dedupe(items) {
  const seen = new Set();
  const out = [];
  for (const it of items) {
    const key = normalizeTitle(it.title);
    if (seen.has(key)) continue;
    seen.add(key);
    out.push(it);
  }
  return out;
}
function safeTime(s) {
  const t = Date.parse(s);
  return Number.isFinite(t) ? t : 0;
}

/* Timestamp format: "Thu 15:07" (local time, 24h) */
function formatStamp(pubDate) {
  const t = safeTime(pubDate);
  if (!t) return "";
  const d = new Date(t);

  const dow = d.toLocaleDateString([], { weekday: "short" });
  const hh = String(d.getHours()).padStart(2, "0");
  const mm = String(d.getMinutes()).padStart(2, "0");

  return dow + " " + hh + ":" + mm;
}

/* Build marquee */
function buildMarquee(items) {
  marqueeEl.innerHTML = "";

  for (const h of items) {
    const span = document.createElement("span");
    span.className = "item";

    const dot = document.createElement("span");
    dot.className = "dot";

    const sourceBlock = document.createElement("span");
    sourceBlock.className = "sourceBlock";

    const src = document.createElement("span");
    src.className = "source";
    src.textContent = h.source;

    const time = document.createElement("span");
    time.className = "time";
    time.textContent = formatStamp(h.pubDate);

    sourceBlock.appendChild(src);
    if (time.textContent) sourceBlock.appendChild(time);

    const a = document.createElement("a");
    a.href = h.link;
    a.target = "_blank";
    a.rel = "noopener noreferrer";

    const title = document.createElement("span");
    title.className = "title";
    title.textContent = h.title;

    a.appendChild(title);

    span.appendChild(dot);
    span.appendChild(sourceBlock);
    span.appendChild(a);

    marqueeEl.appendChild(span);
  }

  const clone = marqueeEl.cloneNode(true);
  clone.id = "";
  marqueeEl.appendChild(clone);
}

/* Scroll animation */
let animId = null;
let x = 0;
let lastTs = null;

function startScroll() {
  if (animId) cancelAnimationFrame(animId);
  x = 0;
  lastTs = null;

  function step(ts) {
    if (lastTs == null) lastTs = ts;
    const dt = (ts - lastTs) / 1000;
    lastTs = ts;

    x -= SPEED_PX_PER_SEC * dt;

    const cycleWidth = marqueeEl.scrollWidth / 2;
    if (cycleWidth > 0 && Math.abs(x) >= cycleWidth) x = 0;

    marqueeEl.style.transform = "translateX(" + x + "px)";
    animId = requestAnimationFrame(step);
  }

  animId = requestAnimationFrame(step);
}

/* Cache */
function saveCache(items) {
  try {
    localStorage.setItem(CACHE_KEY, JSON.stringify({ ts: Date.now(), items }));
  } catch (e) {}
}
function loadCache() {
  try {
    const raw = localStorage.getItem(CACHE_KEY);
    if (!raw) return null;
    const obj = JSON.parse(raw);
    if (!obj || !Array.isArray(obj.items)) return null;
    return obj.items;
  } catch (e) {
    return null;
  }
}

/* Fetch one feed with per-feed limiting */
async function fetchFeed(feed) {
  const candidates = proxyCandidates(feed.url);
  const errors = [];

  for (const u of candidates) {
    try {
      const text = await fetchText(u, 9000);
      const xml = extractXmlMaybe(text) || text;

      let items = parseFeedXml(xml, feed.name);
      if (!items.length) {
        errors.push(feed.name + " parse-empty via " + short(u));
        continue;
      }

      /* newest first, then cap per feed */
      items.sort((a, b) => safeTime(b.pubDate) - safeTime(a.pubDate));
      items = items.slice(0, PER_FEED_MAX);

      return { items, errors };
    } catch (e) {
      errors.push(feed.name + " " + String(e.message || e) + " via " + short(u));
    }
  }

  return { items: [], errors };
}

function short(u) {
  try {
    const url = new URL(u);
    return url.host;
  } catch (e) {
    return "url";
  }
}

/* Main refresh */
async function refresh() {
  showStatus("Refreshing");

  const results = await Promise.allSettled(FEEDS.map(fetchFeed));

  let items = [];
  let errors = [];

  for (const r of results) {
    if (r.status === "fulfilled") {
      items = items.concat(r.value.items);
      errors = errors.concat(r.value.errors);
    }
  }

  items = dedupe(items);
  items.sort((a, b) => safeTime(b.pubDate) - safeTime(a.pubDate));
  items = items.slice(0, MAX_ITEMS);

  if (!items.length) {
    const cached = loadCache();
    if (cached && cached.length) {
      buildMarquee(cached);
      startScroll();
      showStatus("Using cached headlines");
      return;
    }

    if (DEBUG && errors.length) {
      showStatus("No headlines. Last errors: " + errors.slice(0, 3).join(" | "));
    } else {
      showStatus("No headlines available");
    }
    return;
  }

  hideStatus();
  buildMarquee(items);
  startScroll();
  saveCache(items);
}

refresh();
setInterval(refresh, REFRESH_MINUTES * 60 * 1000);
</script>
</body>
</html>

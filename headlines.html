<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Headlines Rev10</title>

<style>
:root{
  --fontSize: 38px;
  --sourceSize: 18px;
  --timeSize: 14px;
  --gap: 30px;
  --dotSize: 8px;
  --padX: 14px;
}

html, body {
  margin: 0;
  padding: 0;
  width: 100%;
  height: 100%;
  background: #000;
  overflow: hidden;
  font-family: Arial, sans-serif;
}

.bar {
  height: 100%;
  width: 100%;
  display: flex;
  align-items: center;
  background: #000;
  color: #fff;
}

.track {
  position: relative;
  flex: 1 1 auto;
  height: 100%;
  display: flex;
  align-items: center;
  overflow: hidden;
  padding: 0 var(--padX);
  box-sizing: border-box;
}

/* Marquee container that we translate */
.marquee {
  position: absolute;
  left: 0;
  top: 50%;
  transform: translateY(-50%);
  will-change: transform;
  display: inline-flex;
  align-items: center;
  white-space: nowrap;
}

/* Two identical runs placed side by side */
.run {
  display: inline-flex;
  align-items: center;
  gap: var(--gap);
  white-space: nowrap;
}

/* Small spacer between run1 and run2 to prevent seam overlap */
.runSpacer {
  width: var(--gap);
  flex: 0 0 auto;
}

.item {
  display: inline-flex;
  align-items: center;
  gap: 12px;
}

.dot {
  width: var(--dotSize);
  height: var(--dotSize);
  border-radius: 50%;
  background: #1f6feb;
  flex: 0 0 auto;
}

.sourceBlock {
  display: flex;
  flex-direction: column;
  line-height: 1;
  margin-right: 6px;
}

.source {
  color: #cdd5df;
  font-weight: 800;
  font-size: var(--sourceSize);
  line-height: 1;
}

.time {
  color: #7f8a96;
  font-weight: 650;
  font-size: var(--timeSize);
  line-height: 1;
  margin-top: 2px;
}

.title {
  color: #ffffff;
  font-weight: 650;
  font-size: var(--fontSize);
}

.status {
  position: absolute;
  inset: 0;
  display: none;
  align-items: center;
  justify-content: flex-start;
  padding: 0 var(--padX);
  color: #f0f0f0;
  font-size: calc(var(--fontSize) - 12px);
  pointer-events: none;
}

a { color: inherit; text-decoration: none; }
</style>
</head>

<body>
<div class="bar">
  <div class="track">
    <div id="status" class="status">Loading...</div>

    <!-- Marquee structure: two runs so we never rely on scrollWidth/2 -->
    <div id="marquee" class="marquee" aria-label="Headlines ticker">
      <div id="run1" class="run"></div>
      <div class="runSpacer" aria-hidden="true"></div>
      <div id="run2" class="run" aria-hidden="true"></div>
    </div>
  </div>
</div>

<script>
/* =========================================================
   Headlines Rev10
   Fix for occasional "duplicates scrolling over itself"

   Root cause in Rev9:
   - It used one container and appended a clone inside it.
   - The animation assumed scrollWidth/2 is always exactly one cycle.
   - When fonts load late, content width changes mid-animation.
   - During refresh, rebuild plus animation frames can momentarily overlap.

   Rev10 fix:
   - Use two separate sibling runs (run1 and run2).
   - Measure run1 width and loop cleanly when x <= -run1Width - spacer.
   - Cancel animation before rebuilding and reset transforms.
   - Wait for fonts (when available) before measuring to avoid width changes.
*/

/* -----------------------------
   Tuning
   ----------------------------- */
const SPEED_PX_PER_SEC = 65;
const PER_FEED_MAX = 3;
const MAX_ITEMS = 40;
const REFRESH_MINUTES = 5;
const DEBUG = false;

/* Feeds */
const FEEDS = [
  { name: "Political Wire", url: "https://politicalwire.com/feed/" },
  { name: "BBC", url: "https://feeds.bbci.co.uk/news/rss.xml" },
  { name: "NBC News", url: "https://feeds.nbcnews.com/nbcnews/public/news" },
  { name: "YWN", url: "https://www.theyeshivaworld.com/article.php/feed" },
  { name: "Middle East Eye", url: "https://feeder.co/discover/5c9c89be31/middleeasteye-net-rss" },
  { name: "Jpost", url: "https://www.jpost.com/rss/rssfeedsfrontpage.aspx" },
  { name: "Times of Israel", url: "https://www.timesofisrael.com/feed/" },
  { name: "IRNA", url: "https://en.irna.ir/rss" },
  { name: "WSVN", url: "https://wsvn.com/feed/" },  
  { name: "AP", url: "https://apnews.com/hub/ap-top-news?output=rss" }
];

const CACHE_KEY = "headlines_rev10_cache_v1";

/* DOM refs */
const statusEl = document.getElementById("status");
const marqueeEl = document.getElementById("marquee");
const run1El = document.getElementById("run1");
const run2El = document.getElementById("run2");

/* Status */
function showStatus(msg) {
  statusEl.style.display = "flex";
  statusEl.textContent = msg;
}
function hideStatus() {
  statusEl.style.display = "none";
}

/* Proxies */
function proxyCandidates(originalUrl) {
  const u = encodeURIComponent(originalUrl);
  return [
    originalUrl,
    "https://api.codetabs.com/v1/proxy?quest=" + u,
    "https://thingproxy.freeboard.io/fetch/" + originalUrl,
    "https://api.allorigins.win/raw?url=" + u
  ];
}

/* Fetch with timeout */
async function fetchText(url, timeoutMs) {
  const controller = new AbortController();
  const t = setTimeout(() => controller.abort(), timeoutMs);
  try {
    const res = await fetch(url, { cache: "no-store", signal: controller.signal });
    if (!res.ok) throw new Error("HTTP " + res.status);
    return await res.text();
  } finally {
    clearTimeout(t);
  }
}

/* Extract XML from wrapper pages */
function extractXmlMaybe(text) {
  const lower = text.toLowerCase();
  const rssStart = lower.indexOf("<rss");
  const feedStart = lower.indexOf("<feed");
  let start = -1;
  let endTag = "";

  if (rssStart !== -1 && (feedStart === -1 || rssStart < feedStart)) {
    start = rssStart;
    endTag = "</rss>";
  } else if (feedStart !== -1) {
    start = feedStart;
    endTag = "</feed>";
  }

  if (start === -1) return "";
  const end = lower.lastIndexOf(endTag);
  if (end === -1) return text.slice(start);
  return text.slice(start, end + endTag.length);
}

/* Parse RSS + Atom */
function parseFeedXml(xmlText, sourceName) {
  const doc = new DOMParser().parseFromString(xmlText, "text/xml");
  if (doc.querySelector("parsererror")) return [];

  const out = [];

  /* RSS */
  const items = Array.from(doc.querySelectorAll("item"));
  for (const it of items) {
    const title = (it.querySelector("title")?.textContent || "").trim();

    let link = (it.querySelector("link")?.textContent || "").trim();
    if (!link) {
      const guid = it.querySelector("guid");
      const isPermalink = (guid?.getAttribute("isPermaLink") || "").toLowerCase() === "true";
      if (isPermalink) link = (guid?.textContent || "").trim();
    }

    const pubDate =
      (it.querySelector("pubDate")?.textContent || "").trim() ||
      (it.querySelector("dc\\:date")?.textContent || "").trim() ||
      "";

    if (title && link) out.push({ title, link, pubDate, source: sourceName });
  }

  /* Atom */
  const entries = Array.from(doc.querySelectorAll("entry"));
  for (const e of entries) {
    const title = (e.querySelector("title")?.textContent || "").trim();

    let link = "";
    const linkEl = e.querySelector('link[rel="alternate"]') || e.querySelector("link");
    if (linkEl) link = (linkEl.getAttribute("href") || "").trim();

    const pubDate =
      (e.querySelector("updated")?.textContent || "").trim() ||
      (e.querySelector("published")?.textContent || "").trim() ||
      "";

    if (title && link) out.push({ title, link, pubDate, source: sourceName });
  }

  return out;
}

/* Helpers */
function normalizeTitle(t) {
  return t.toLowerCase().replace(/\s+/g, " ").replace(/[“”"']/g, "").trim();
}
function dedupe(items) {
  const seen = new Set();
  const out = [];
  for (const it of items) {
    const key = normalizeTitle(it.title);
    if (seen.has(key)) continue;
    seen.add(key);
    out.push(it);
  }
  return out;
}
function safeTime(s) {
  const t = Date.parse(s);
  return Number.isFinite(t) ? t : 0;
}

/* Timestamp: "Thu 15:07" */
function formatStamp(pubDate) {
  const t = safeTime(pubDate);
  if (!t) return "";
  const d = new Date(t);
  const dow = d.toLocaleDateString([], { weekday: "short" });
  const hh = String(d.getHours()).padStart(2, "0");
  const mm = String(d.getMinutes()).padStart(2, "0");
  return dow + " " + hh + ":" + mm;
}

/* Cache */
function saveCache(items) {
  try {
    localStorage.setItem(CACHE_KEY, JSON.stringify({ ts: Date.now(), items }));
  } catch (e) {}
}
function loadCache() {
  try {
    const raw = localStorage.getItem(CACHE_KEY);
    if (!raw) return null;
    const obj = JSON.parse(raw);
    if (!obj || !Array.isArray(obj.items)) return null;
    return obj.items;
  } catch (e) {
    return null;
  }
}

/* Feed fetch with per-feed limiting */
async function fetchFeed(feed) {
  const candidates = proxyCandidates(feed.url);
  const errors = [];

  for (const u of candidates) {
    try {
      const text = await fetchText(u, 9000);
      const xml = extractXmlMaybe(text) || text;

      let items = parseFeedXml(xml, feed.name);
      if (!items.length) {
        errors.push(feed.name + " parse-empty via " + short(u));
        continue;
      }

      items.sort((a, b) => safeTime(b.pubDate) - safeTime(a.pubDate));
      items = items.slice(0, PER_FEED_MAX);

      return { items, errors };
    } catch (e) {
      errors.push(feed.name + " " + String(e.message || e) + " via " + short(u));
    }
  }

  return { items: [], errors };
}

function short(u) {
  try {
    return new URL(u).host;
  } catch (e) {
    return "url";
  }
}

/* Build one run (run1), then clone into run2 as siblings */
function buildRuns(items) {
  run1El.innerHTML = "";
  run2El.innerHTML = "";

  for (const h of items) {
    const item = document.createElement("span");
    item.className = "item";

    const dot = document.createElement("span");
    dot.className = "dot";

    const sourceBlock = document.createElement("span");
    sourceBlock.className = "sourceBlock";

    const src = document.createElement("span");
    src.className = "source";
    src.textContent = h.source;

    const time = document.createElement("span");
    time.className = "time";
    time.textContent = formatStamp(h.pubDate);

    sourceBlock.appendChild(src);
    if (time.textContent) sourceBlock.appendChild(time);

    const a = document.createElement("a");
    a.href = h.link;
    a.target = "_blank";
    a.rel = "noopener noreferrer";

    const title = document.createElement("span");
    title.className = "title";
    title.textContent = h.title;

    a.appendChild(title);

    item.appendChild(dot);
    item.appendChild(sourceBlock);
    item.appendChild(a);

    run1El.appendChild(item);
  }

  /* Clone run1 into run2 */
  run2El.appendChild(run1El.cloneNode(true));
}

/* Animation state */
let animId = null;
let x = 0;
let lastTs = null;
let cycleWidth = 0;
let isAnimating = false;

/* Ensure we measure after fonts are ready, so width stays stable */
async function waitForFonts() {
  if (document.fonts && document.fonts.ready) {
    try { await document.fonts.ready; } catch (e) {}
  } else {
    await new Promise(r => setTimeout(r, 50));
  }
}

/* Measure one cycle width: run1 width plus spacer */
function measureCycleWidth() {
  const spacer = marqueeEl.querySelector(".runSpacer");
  const spacerW = spacer ? spacer.getBoundingClientRect().width : 0;
  const run1W = run1El.getBoundingClientRect().width;
  cycleWidth = run1W + spacerW;
}

/* Stop animation cleanly */
function stopScroll() {
  if (animId) cancelAnimationFrame(animId);
  animId = null;
  isAnimating = false;
  x = 0;
  lastTs = null;
  marqueeEl.style.transform = "translateY(-50%) translateX(0px)";
}

/* Start animation using measured cycleWidth */
function startScroll() {
  stopScroll();
  if (!cycleWidth || cycleWidth < 10) return;

  isAnimating = true;

  function step(ts) {
    if (!isAnimating) return;

    if (lastTs == null) lastTs = ts;
    const dt = (ts - lastTs) / 1000;
    lastTs = ts;

    x -= SPEED_PX_PER_SEC * dt;

    /* When the first run has fully moved left, reset to 0 */
    if (x <= -cycleWidth) x = 0;

    marqueeEl.style.transform = "translateY(-50%) translateX(" + x + "px)";
    animId = requestAnimationFrame(step);
  }

  animId = requestAnimationFrame(step);
}

/* Re-measure on resize */
window.addEventListener("resize", () => {
  if (!run1El.children.length) return;
  measureCycleWidth();
});

/* Main refresh */
async function refresh() {
  showStatus("Refreshing");

  /* Prevent rebuild while animating */
  stopScroll();

  const results = await Promise.allSettled(FEEDS.map(fetchFeed));

  let items = [];
  let errors = [];

  for (const r of results) {
    if (r.status === "fulfilled") {
      items = items.concat(r.value.items);
      errors = errors.concat(r.value.errors);
    }
  }

  items = dedupe(items);
  items.sort((a, b) => safeTime(b.pubDate) - safeTime(a.pubDate));
  items = items.slice(0, MAX_ITEMS);

  if (!items.length) {
    const cached = loadCache();
    if (cached && cached.length) {
      buildRuns(cached);
      await waitForFonts();
      measureCycleWidth();
      startScroll();
      showStatus("Using cached headlines");
      return;
    }

    if (DEBUG && errors.length) {
      showStatus("No headlines. Last errors: " + errors.slice(0, 3).join(" | "));
    } else {
      showStatus("No headlines available");
    }
    return;
  }

  hideStatus();
  buildRuns(items);

  /* Wait for fonts then measure and scroll so widths do not change mid-run */
  await waitForFonts();
  measureCycleWidth();
  startScroll();
  saveCache(items);
}

refresh();
setInterval(refresh, REFRESH_MINUTES * 60 * 1000);
</script>
</body>
</html>

<!--
Live Flights Kiosk Map (map-only, single HTML)
=============================================

Night radar preset (visual-only changes)
- Dark basemap attribution fixed
- Radar tint overlay on top of tiles
- Stronger neon trails + glow
- Plane icons get a subtle glow
- Labels retuned for "airport geek" night mode
- Removed DIST from the flight info box (visual only)

-->

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Live Flights Map Demo3</title>

  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
  ></script>

  <style>
    :root{
      --bg: #05070b;

      --text: #d9f2ff;
      --muted: rgba(190,235,255,0.68);

      /* neon radar palette */
      --climb: #32ff9a;
      --level: #6bd3ff;
      --desc:  #ff4f66;

      --accent: #7ae7ff;

      /* radar tint overlay */
      --radarTint: rgba(20, 255, 210, 0.08);
      --radarVignette: rgba(0,0,0,0.55);

      --font: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
    }

    html, body {
      height: 100%;
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font-family: var(--font);
      overflow: hidden;
    }

    #map {
      width: 100vw;
      height: 100vh;
      position: relative;
      isolation: isolate;
    }

    /* Slightly mute tiles to feel like a scope */
    .leaflet-tile {
      filter: saturate(0.75) brightness(0.72) contrast(1.06);
    }

    /* Radar overlay: tint + vignette (no functional impact) */
    #map::after{
      content: "";
      position: absolute;
      inset: 0;
      pointer-events: none;
      z-index: 550;
      background:
        radial-gradient(circle at 50% 55%, rgba(0,0,0,0) 35%, var(--radarVignette) 78%),
        linear-gradient(180deg, rgba(0,0,0,0.28), rgba(0,0,0,0.20)),
        var(--radarTint);
      mix-blend-mode: screen;
    }

    .leaflet-control-attribution {
      background: rgba(0,0,0,0.32) !important;
      color: rgba(255,255,255,0.70) !important;
      border-radius: 10px;
      padding: 2px 8px !important;
      margin: 0 10px 10px 0 !important;
    }
    .leaflet-control-zoom a {
      background: rgba(0,0,0,0.38) !important;
      color: rgba(255,255,255,0.90) !important;
      border: 1px solid rgba(255,255,255,0.14) !important;
    }

    /* Flight info tag */
    .ac-tag {
      background: rgba(6, 12, 16, 0.86);
      border: 1px solid rgba(122, 231, 255, 0.18);
      border-radius: 12px;
      padding: 8px 10px;
      box-shadow:
        0 14px 28px rgba(0,0,0,0.50),
        0 0 0 1px rgba(50,255,154,0.06),
        0 0 18px rgba(107,211,255,0.10);
      backdrop-filter: blur(7px);

      min-width: 165px;
      max-width: 290px;

      line-height: 1.22;
    }

    .ac-top {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .ac-flight {
      font-weight: 900;
      font-size: 14px;
      letter-spacing: 0.2px;
      color: var(--accent);
      text-shadow: 0 0 12px rgba(122,231,255,0.18);
    }

    .ac-pill {
      display: inline-block;
      padding: 2px 7px;
      border-radius: 999px;
      font-size: 10px;
      font-weight: 900;
      font-family: var(--mono);
      border: 1px solid rgba(255,255,255,0.14);
      transform: translateY(1px);
      white-space: nowrap;
    }
    .ac-pill.climb { color: var(--climb); }
    .ac-pill.level { color: var(--level); }
    .ac-pill.desc  { color: var(--desc); }

    .ac-airline {
      margin-top: 5px;
      font-size: 11px;
      color: rgba(220,250,255,0.92);
    }

    .ac-route {
      margin-top: 2px;
      font-size: 10px;
      color: var(--muted);
      font-family: var(--mono);
      letter-spacing: 0.15px;
    }

    .ac-metrics {
      margin-top: 7px;
      display: grid;
      grid-template-columns: auto 1fr;
      gap: 5px 8px;
      align-items: baseline;

      font-family: var(--mono);
      font-size: 11px;
      color: rgba(220,250,255,0.92);
    }

    .ac-k {
      color: rgba(190,235,255,0.62);
      font-weight: 900;
      letter-spacing: 0.45px;
      font-size: 10px;
    }

    .ac-type {
      margin-top: 7px;
      font-size: 10px;
      color: rgba(190,235,255,0.72);
    }

    .ac-hex {
      margin-top: 5px;
      font-family: var(--mono);
      font-size: 9px;
      color: rgba(190,235,255,0.52);
    }

    .plane-icon {
      width: 26px;
      height: 26px;
      transform-origin: 50% 50%;
      filter:
        drop-shadow(0 10px 14px rgba(0,0,0,0.45))
        drop-shadow(0 0 10px rgba(107,211,255,0.14));
    }

    /* Custom label overlay that we clamp to the viewport */
    .ac-label {
      position: absolute;
      left: 0;
      top: 0;
      pointer-events: none;
      transform: translate3d(0,0,0);
      will-change: transform;
      z-index: 650;
    }

    /* One-line status bar across bottom */
    #statusBar {
      position: fixed;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 9999;

      background: rgba(0,0,0,0.58);
      border-top: 1px solid rgba(122, 231, 255, 0.16);
      padding: 6px 10px;

      font-family: var(--mono);
      font-size: 12px;
      line-height: 1.15;
      color: rgba(220,250,255,0.86);

      pointer-events: none;
      backdrop-filter: blur(8px);

      display: flex;
      gap: 14px;
      align-items: center;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;

      box-shadow: 0 -12px 26px rgba(0,0,0,0.35);
    }

    #statusBar .k { color: rgba(190,235,255,0.58); }
    #statusBar .ok { color: var(--climb); font-weight: 800; text-shadow: 0 0 10px rgba(50,255,154,0.14); }
    #statusBar .warn { color: #ffd36b; font-weight: 800; }
    #statusBar .bad { color: var(--desc); font-weight: 800; }

    #statusBar .spacer {
      flex: 1 1 auto;
      min-width: 10px;
    }

    /* Make the trail pop */
    .leaflet-overlay-pane svg path {
      stroke-linecap: round;
      stroke-linejoin: round;
      filter: drop-shadow(0 0 6px rgba(107,211,255,0.14));
    }
  </style>
</head>

<body>
  <div id="map"></div>

  <div id="statusBar" aria-hidden="true">
    <span class="k">st</span><span id="st_air" class="warn">starting</span>
    <span class="k">last ok</span><span id="st_lastok">n/a</span>
    <span class="k">lat</span><span id="st_latency">n/a</span>
    <span class="k">ac</span><span id="st_count">0</span>
    <span class="k">q</span><span id="st_q">0</span>
    <span class="k">tick</span><span id="st_tick">n/a</span>
    <span class="k">err</span><span id="st_err">n/a</span>
  </div>

  <script>
    /***********************************************************************
     * SETTINGS (EDIT THESE)  <span class="spacer"></span> 
     ***********************************************************************
     * These are the only values you should need to change most of the time.
     ***********************************************************************/

    // Map view
    const MAP_CENTER_LAT = 26.0720;
    const MAP_CENTER_LON = -80.1850;
    const MAP_ZOOM = 14;

    // Data fetch location and radius
    const FETCH_LAT = MAP_CENTER_LAT;
    const FETCH_LON = MAP_CENTER_LON;
    const SEARCH_RADIUS_NM = 2.4;

    // Update loop
    const UPDATE_MS = 5000;
    const FETCH_TIMEOUT_MS = 1500;

    // Remove aircraft if not seen for this long (stale timeout)
    const STALE_AIRCRAFT_MS = 60_000;

    // Labels
    const MAX_LABELED_AIRCRAFT = 8;
    const LABEL_MAX_DISTANCE_MI = 2.4;   // set null to disable
    const LABEL_ONLY_BELOW_FT = 10000;   // set null to disable
    const HISTORY_POINTS = 10;

    // Climb/descent thresholds
    const CLIMB_FPM_THRESHOLD = 500;
    const DESC_FPM_THRESHOLD  = -500;

    // Only show the flight info box if the plane is airborne
    const AIRBORNE_MIN_FT = 50;

    // Keep labels on-screen with a safe margin
    const LABEL_SCREEN_PADDING_PX = 12;
    const LABEL_OFFSET_Y_PX = 16;

    // Optional enrichment (route, aircraft type)
    const ADSBDB_ENABLE = true;
    const ADSBDB_CALLSIGN_TTL_MS = 6 * 60 * 1000;
    const ADSBDB_HEX_TTL_MS      = 6 * 60 * 60 * 1000;

    /**************************************************************
     * STATUS OVERLAY STATE
     **************************************************************/
    const st = {
      lastOkMs: null,
      lastLatencyMs: null,
      lastCount: 0,
      lastErr: null,
      lastErrDetail: null,
      lastTickDurMs: null,
    };

    const stAir = document.getElementById("st_air");
    const stLastOk = document.getElementById("st_lastok");
    const stLatency = document.getElementById("st_latency");
    const stCount = document.getElementById("st_count");
    const stQ = document.getElementById("st_q");
    const stTick = document.getElementById("st_tick");
    const stErr = document.getElementById("st_err");

    function fmtClock(ms) {
      if (!ms) return "n/a";
      return new Date(ms).toLocaleTimeString();
    }

    function setAirStatus(kind, text) {
      stAir.className = kind;
      stAir.textContent = text;
    }

    function renderStatus() {
      stLastOk.textContent = fmtClock(st.lastOkMs);
      stLatency.textContent = (st.lastLatencyMs === null) ? "n/a" : `${Math.round(st.lastLatencyMs)}ms`;
      stCount.textContent = `${st.lastCount}`;
      stQ.textContent = `${enrichQueue.length}${enrichBusy ? "*" : ""}`;

      if (st.lastTickDurMs === null) {
        stTick.textContent = "n/a";
      } else {
        const sinceOk = st.lastOkMs ? Math.max(0, (Date.now() - st.lastOkMs)) : null;
        const sinceOkTxt = (sinceOk === null) ? "n/a" : `${Math.round(sinceOk/100)/10}s`;
        stTick.textContent = `${Math.round(st.lastTickDurMs)}ms okAge ${sinceOkTxt}`;
      }

      if (!st.lastErr) {
        stErr.textContent = "n/a";
      } else {
        const compact = st.lastErrDetail ? `${st.lastErr}:${st.lastErrDetail}` : st.lastErr;
        stErr.textContent = compact.slice(0, 44);
      }
    }

    /**************************************************************
     * UTILITIES
     **************************************************************/
    const NM_TO_METERS = 1852;
    const MI_TO_METERS = 1609.344;

    function haversineMeters(lat1, lon1, lat2, lon2) {
      const R = 6371000;
      const toRad = (d) => d * Math.PI / 180;
      const dLat = toRad(lat2 - lat1);
      const dLon = toRad(lon2 - lon1);
      const a = Math.sin(dLat/2)**2 +
                Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
                Math.sin(dLon/2)**2;
      return 2 * R * Math.asin(Math.sqrt(a));
    }

    function safeText(v) {
      if (v === null || v === undefined) return "n/a";
      const s = String(v).trim();
      return s.length ? s : "n/a";
    }

    function fmtNum(n, digits=1) {
      if (n === null || n === undefined || Number.isNaN(n)) return "n/a";
      return Number(n).toFixed(digits);
    }

    function fmtAltFeet(meters) {
      if (meters === null || meters === undefined || Number.isNaN(meters)) return "n/a";
      const ft = meters * 3.28084;
      return `${Math.round(ft).toLocaleString()} ft`;
    }

    function fmtSpeedKt(ms) {
      if (ms === null || ms === undefined || Number.isNaN(ms)) return "n/a";
      const kt = ms * 1.943844;
      return `${Math.round(kt)} kt`;
    }

    function fmtFpmFromMs(vrateMs) {
      if (vrateMs === null || vrateMs === undefined || Number.isNaN(vrateMs)) return null;
      return Math.round(vrateMs * 196.850394);
    }

    function pickLatLon(ac) {
      if (typeof ac.lat === "number" && typeof ac.lon === "number") return { lat: ac.lat, lon: ac.lon };
      if (ac.lastPosition && typeof ac.lastPosition.lat === "number" && typeof ac.lastPosition.lon === "number") {
        return { lat: ac.lastPosition.lat, lon: ac.lastPosition.lon };
      }
      if (typeof ac.rr_lat === "number" && typeof ac.rr_lon === "number") return { lat: ac.rr_lat, lon: ac.rr_lon };
      return null;
    }

    function aircraftAltMeters(ac) {
      const a = ac.alt_baro ?? ac.alt_geom ?? ac.alt;
      return (typeof a === "number") ? a : null;
    }

    function aircraftSpeedMs(ac) {
      const s = ac.gs ?? ac.spd ?? ac.speed;
      return (typeof s === "number") ? s : null;
    }

    function aircraftVrateMs(ac) {
      const r = ac.baro_rate ?? ac.geom_rate ?? ac.rate;
      return (typeof r === "number") ? r : null;
    }

    function aircraftTrackDeg(ac) {
      const t = ac.track ?? ac.hdg ?? ac.heading;
      return (typeof t === "number") ? t : 0;
    }

    function altFeetFromMeters(meters) {
      if (meters === null || meters === undefined || Number.isNaN(meters)) return null;
      return meters * 3.28084;
    }

    function climbStateFromFpm(fpm) {
      if (fpm === null || fpm === undefined) return "level";
      if (fpm >= CLIMB_FPM_THRESHOLD) return "climb";
      if (fpm <= DESC_FPM_THRESHOLD) return "desc";
      return "level";
    }

    function stateText(state) {
      if (state === "climb") return "CLIMB";
      if (state === "desc") return "DESC";
      return "LEVEL";
    }

    function stateEmoji(state) {
      if (state === "climb") return "ðŸ›«";
      if (state === "desc") return "ðŸ›¬";
      return "âœˆï¸";
    }

    function getCss(varName) {
      return getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
    }

    function stateColor(state) {
      if (state === "climb") return getCss("--climb");
      if (state === "desc")  return getCss("--desc");
      return getCss("--level");
    }

    function distanceMi(latLng) {
      const dM = haversineMeters(FETCH_LAT, FETCH_LON, latLng.lat, latLng.lng);
      return dM / MI_TO_METERS;
    }

    function airplanesLiveUrl() {
      const base = `https://api.airplanes.live/v2/point/${encodeURIComponent(FETCH_LAT)}/${encodeURIComponent(FETCH_LON)}/${encodeURIComponent(SEARCH_RADIUS_NM)}`;
      return `${base}?t=${Date.now()}`;
    }

    function normalizeAircraftList(raw) {
      if (!raw) return [];
      if (Array.isArray(raw.ac)) return raw.ac;
      if (Array.isArray(raw.aircraft)) return raw.aircraft;
      if (Array.isArray(raw)) return raw;
      return [];
    }

    function isAirborne(ac, altFt) {
      if (ac && ac.on_ground === true) return false;
      if (altFt === null || altFt === undefined || Number.isNaN(altFt)) return false;
      return altFt >= AIRBORNE_MIN_FT;
    }

    /**************************************************************
     * MAP SETUP
     **************************************************************/
    const map = L.map("map", { zoomControl: true });

    L.tileLayer("https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png", {
      maxZoom: 19,
      attribution: "&copy; OpenStreetMap &copy; CARTO"
    }).addTo(map);

    map.setView([MAP_CENTER_LAT, MAP_CENTER_LON], MAP_ZOOM);

    /* Radar ring (keep same geometry, but more scope-like styling) */
    L.circle([FETCH_LAT, FETCH_LON], {
      radius: SEARCH_RADIUS_NM * NM_TO_METERS,
      weight: 1,
      opacity: 0.55,
      color: "rgba(122,231,255,0.45)",
      fillOpacity: 0.03,
      fillColor: "rgba(50,255,154,0.08)"
    }).addTo(map);

    /* Center point */
    //L.circleMarker([FETCH_LAT, FETCH_LON], {
    //  radius: 6,
    //  weight: 2,
    //  opacity: 1,
    //  color: "rgba(122,231,255,0.7)",
    //  fillOpacity: 0.9,
    //  fillColor: "rgba(50,255,154,0.65)"
    //}).addTo(map);

    // Label layer container (inside map overlay pane)
    const labelLayer = document.createElement("div");
    labelLayer.style.position = "absolute";
    labelLayer.style.left = "0";
    labelLayer.style.top = "0";
    labelLayer.style.width = "100%";
    labelLayer.style.height = "100%";
    labelLayer.style.pointerEvents = "none";
    map.getPanes().overlayPane.appendChild(labelLayer);

    /**************************************************************
     * ENRICHMENT (ADSBDB), cached and queued
     **************************************************************/
    const callsignCache = new Map();
    const hexCache = new Map();

    function getCached(cache, key, ttlMs) {
      const v = cache.get(key);
      if (!v) return undefined;
      if ((Date.now() - v.ts) > ttlMs) return undefined;
      return v.data;
    }
    function setCached(cache, key, data) {
      cache.set(key, { ts: Date.now(), data });
    }

    const enrichQueue = [];
    let enrichBusy = false;
    let adsbdbErrCount = 0;

    function enqueueEnrich(job) {
      enrichQueue.push(job);
      renderStatus();
      runEnrichQueue();
    }

    async function runEnrichQueue() {
      if (enrichBusy) return;
      enrichBusy = true;
      renderStatus();

      while (enrichQueue.length) {
        const job = enrichQueue.shift();
        try { await job(); }
        catch (e) { adsbdbErrCount++; }
        await new Promise(r => setTimeout(r, 120));
        renderStatus();
      }

      enrichBusy = false;
      renderStatus();
    }

    async function fetchJson(url) {
      const res = await fetch(url, { cache: "no-store" });
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      return res.json();
    }

    function parseAdsbdbRoute(payload) {
      const root = payload && payload.response ? payload.response : null;
      const fr = root && root.flightroute ? root.flightroute : null;
      if (!fr) return null;

      const airline = fr.airline || null;
      const origin = fr.origin || null;
      const dest = fr.destination || null;

      return {
        airlineName: airline ? safeText(airline.name) : "n/a",
        originIcao: origin ? safeText(origin.icao_code) : "n/a",
        originIata: origin ? safeText(origin.iata_code) : "n/a",
        destIcao: dest ? safeText(dest.icao_code) : "n/a",
        destIata: dest ? safeText(dest.iata_code) : "n/a",
      };
    }

    function parseAdsbdbAircraft(payload) {
      const root = payload && payload.response ? payload.response : null;
      const ac = root && root.aircraft ? root.aircraft : null;
      if (!ac) return null;

      return {
        icaoType: safeText(ac.icao_type),
        type: safeText(ac.type),
        manufacturer: safeText(ac.manufacturer),
        registration: safeText(ac.registration),
      };
    }

    async function ensureRouteForCallsign(callsign) {
      const cs = safeText(callsign).toUpperCase();
      if (cs === "N/A") return null;

      const cached = getCached(callsignCache, cs, ADSBDB_CALLSIGN_TTL_MS);
      if (cached !== undefined) return cached;

      setCached(callsignCache, cs, null);
      try {
        const json = await fetchJson(`https://api.adsbdb.com/v0/callsign/${encodeURIComponent(cs)}`);
        const data = parseAdsbdbRoute(json);
        setCached(callsignCache, cs, data);
        return data;
      } catch (e) {
        adsbdbErrCount++;
        setCached(callsignCache, cs, null);
        return null;
      }
    }

    async function ensureAircraftForHex(hex) {
      const hx = safeText(hex).toUpperCase();
      if (hx === "N/A") return null;

      const cached = getCached(hexCache, hx, ADSBDB_HEX_TTL_MS);
      if (cached !== undefined) return cached;

      setCached(hexCache, hx, null);
      try {
        const json = await fetchJson(`https://api.adsbdb.com/v0/aircraft/${encodeURIComponent(hx)}`);
        const data = parseAdsbdbAircraft(json);
        setCached(hexCache, hx, data);
        return data;
      } catch (e) {
        adsbdbErrCount++;
        setCached(hexCache, hx, null);
        return null;
      }
    }

    /**************************************************************
     * PLANE ICON (inline SVG, rotated)
     **************************************************************/
    function planeSvg(color) {
      return `
        <svg class="plane-icon" viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
          <path fill="${color}" d="M30 4c1.5 0 3 1.2 3 3v18l20 12c1.4.8 2 2.6 1.2 4l-1.5 2.6c-.8 1.4-2.6 1.9-4 1.1L33 36v9l8 6c1 .8 1.3 2.2.7 3.3l-1.2 2c-.7 1.2-2.2 1.6-3.5 1l-8.9-4.6-8.9 4.6c-1.3.6-2.8.2-3.5-1l-1.2-2c-.6-1.1-.3-2.5.7-3.3l8-6v-9L15.3 47.3c-1.4.8-3.2.3-4-1.1L9.8 43.6c-.8-1.4-.2-3.2 1.2-4l20-12V7c0-1.8 1.5-3 3-3z"/>
        </svg>
      `;
    }

    function makePlaneDivIcon(color, headingDeg) {
      const h = (typeof headingDeg === "number") ? headingDeg : 0;
      const html = `<div style="transform: rotate(${h}deg);">${planeSvg(color)}</div>`;
      return L.divIcon({
        className: "",
        html,
        iconSize: [26, 26],
        iconAnchor: [13, 13]
      });
    }

    /**************************************************************
     * AIRCRAFT STATE + LABELS
     **************************************************************/
    const aircraftState = new Map();

    function routeShort(route) {
      if (!route) return "";
      const o = (route.originIata && route.originIata !== "n/a") ? route.originIata : (route.originIcao || "");
      const d = (route.destIata && route.destIata !== "n/a") ? route.destIata : (route.destIcao || "");
      if (!o || !d || o === "n/a" || d === "n/a") return "";
      return `${o} â†’ ${d}`;
    }

    function bestType(acPayload, aircraftInfo) {
      const fallback = safeText(acPayload.t || acPayload.type);
      if (!aircraftInfo) return fallback;

      const mt = (aircraftInfo.manufacturer && aircraftInfo.manufacturer !== "n/a") ? aircraftInfo.manufacturer : "";
      const t  = (aircraftInfo.type && aircraftInfo.type !== "n/a") ? aircraftInfo.type : "";
      const it = (aircraftInfo.icaoType && aircraftInfo.icaoType !== "n/a") ? aircraftInfo.icaoType : "";
      const joined = [mt, t].filter(Boolean).join(" ");
      return joined || it || fallback;
    }

    function buildTag(entry) {
      const ac = entry.lastPayload || {};
      const callsign = safeText(ac.flight || ac.callsign).toUpperCase();
      const hex = safeText(ac.hex).toUpperCase();

      const route = entry.routeInfo;
      const airlineName = route && route.airlineName && route.airlineName !== "n/a" ? route.airlineName : "";
      const rt = routeShort(route);

      const alt = fmtAltFeet(aircraftAltMeters(ac));
      const spd = fmtSpeedKt(aircraftSpeedMs(ac));
      const vr  = (entry.fpm === null || entry.fpm === undefined) ? "n/a" : `${entry.fpm > 0 ? "+" : ""}${entry.fpm} fpm`;
      const typeTxt = bestType(ac, entry.aircraftInfo);

      return `
        <div class="ac-tag">
          <div class="ac-top">
            <div class="ac-flight">${callsign}</div>
            <div class="ac-pill ${entry.state}">${stateEmoji(entry.state)} ${stateText(entry.state)}</div>
          </div>

          ${airlineName ? `<div class="ac-airline">${airlineName}</div>` : ``}
          ${rt ? `<div class="ac-route">${rt}</div>` : ``}

          <div class="ac-metrics">
            <div class="ac-k">ALT</div><div>${alt}</div>
            <div class="ac-k">SPD</div><div>${spd}</div>
            <div class="ac-k">VR</div><div>${vr}</div>
          </div>

          <div class="ac-type">${typeTxt}</div>
          <div class="ac-hex">${hex}</div>
        </div>
      `;
    }

    function ensureLabelDiv(entry) {
      if (entry.labelDiv) return;
      const d = document.createElement("div");
      d.className = "ac-label";
      d.style.display = "none";
      labelLayer.appendChild(d);
      entry.labelDiv = d;
      entry.labelHtml = "";
      entry.labelW = 0;
      entry.labelH = 0;
    }

    function measureLabel(entry) {
      if (!entry.labelDiv) return;
      const d = entry.labelDiv;

      const prevDisplay = d.style.display;
      const prevVis = d.style.visibility;

      d.style.visibility = "hidden";
      d.style.display = "block";

      const r = d.getBoundingClientRect();
      entry.labelW = Math.round(r.width);
      entry.labelH = Math.round(r.height);

      d.style.visibility = prevVis;
      d.style.display = prevDisplay;
    }

    function setLabelVisible(entry, visible) {
      if (!entry.labelDiv) return;
      entry.labelDiv.style.display = visible ? "block" : "none";
    }

    function clamp(n, lo, hi) {
      return Math.max(lo, Math.min(hi, n));
    }

    function positionLabel(entry) {
      if (!entry.labelDiv) return;
      if (!entry.labelWanted) return;

      const latLng = entry.marker.getLatLng();
      const p = map.latLngToContainerPoint(latLng);

      const w = entry.labelW || 0;
      const h = entry.labelH || 0;

      const mapSize = map.getSize();
      const pad = LABEL_SCREEN_PADDING_PX;

      let x = p.x - (w / 2);
      let y = p.y - h - LABEL_OFFSET_Y_PX;

      x = clamp(x, pad, mapSize.x - w - pad);
      y = clamp(y, pad, mapSize.y - h - pad);

      entry.labelDiv.style.transform = `translate3d(${Math.round(x)}px, ${Math.round(y)}px, 0)`;
    }

    function applyLabel(entry) {
      ensureLabelDiv(entry);

      if (!entry.labelWanted) {
        setLabelVisible(entry, false);
        return;
      }

      const html = buildTag(entry);
      if (html !== entry.labelHtml) {
        entry.labelHtml = html;
        entry.labelDiv.innerHTML = html;
        measureLabel(entry);
      }

      setLabelVisible(entry, true);
      positionLabel(entry);
    }

    function upsertAircraft(ac, nowMs) {
      const hex = safeText(ac.hex);
      if (hex === "n/a") return null;

      const pos = pickLatLon(ac);
      if (!pos) return null;

      const latLng = L.latLng(pos.lat, pos.lon);

      const dist = distanceMi(latLng);
      const altM = aircraftAltMeters(ac);
      const altFt = altFeetFromMeters(altM);

      const fpm = fmtFpmFromMs(aircraftVrateMs(ac));
      const state = climbStateFromFpm(fpm);

      const heading = aircraftTrackDeg(ac);
      const color = stateColor(state);

      let entry = aircraftState.get(hex);
      if (!entry) {
        const marker = L.marker(latLng, {
          icon: makePlaneDivIcon(color, heading),
          interactive: false,
          keyboard: false
        }).addTo(map);

        /* brighter, thicker trail in night mode */
        const poly = L.polyline([], { weight: 2.6, opacity: 0.72, color }).addTo(map);

        entry = {
          marker,
          poly,
          history: [],
          lastSeenTs: nowMs,
          lastPayload: ac,
          routeInfo: null,
          aircraftInfo: null,
          distMi: dist,
          altFt: altFt,
          fpm: fpm,
          state: state,
          labelWanted: false,
          labelDiv: null,
          labelHtml: "",
          labelW: 0,
          labelH: 0
        };
        aircraftState.set(hex, entry);
        ensureLabelDiv(entry);
      }

      entry.lastSeenTs = nowMs;
      entry.lastPayload = ac;
      entry.distMi = dist;
      entry.altFt = altFt;
      entry.fpm = fpm;
      entry.state = state;

      entry.history.push({ lat: pos.lat, lon: pos.lon, ts: nowMs });
      if (entry.history.length > HISTORY_POINTS) entry.history.shift();

      entry.marker.setLatLng(latLng);
      entry.marker.setIcon(makePlaneDivIcon(color, heading));

      entry.poly.setStyle({ color, opacity: 0.72, weight: 2.6 });
      entry.poly.setLatLngs(entry.history.map(p => [p.lat, p.lon]));

      if (ADSBDB_ENABLE) {
        const callsign = safeText(ac.flight || ac.callsign).toUpperCase();

        if (callsign !== "N/A" && callsign !== "n/a" && entry.routeInfo === null) {
          enqueueEnrich(async () => {
            const route = await ensureRouteForCallsign(callsign);
            if (route) entry.routeInfo = route;
            renderStatus();
          });
        }

        if (entry.aircraftInfo === null) {
          enqueueEnrich(async () => {
            const info = await ensureAircraftForHex(hex);
            if (info) entry.aircraftInfo = info;
            renderStatus();
          });
        }
      }

      return entry;
    }

    function pruneStale(nowMs) {
      for (const [hex, entry] of aircraftState.entries()) {
        if (nowMs - entry.lastSeenTs > STALE_AIRCRAFT_MS) {
          map.removeLayer(entry.marker);
          map.removeLayer(entry.poly);
          if (entry.labelDiv && entry.labelDiv.parentNode) entry.labelDiv.parentNode.removeChild(entry.labelDiv);
          aircraftState.delete(hex);
        }
      }
    }

    function decideLabels() {
      const all = Array.from(aircraftState.values());

      const eligible = all.filter(e => {
        const ac = e.lastPayload || {};
        if (!isAirborne(ac, e.altFt)) return false;

        if (LABEL_MAX_DISTANCE_MI !== null && e.distMi > LABEL_MAX_DISTANCE_MI) return false;
        if (LABEL_ONLY_BELOW_FT !== null && e.altFt !== null && e.altFt > LABEL_ONLY_BELOW_FT) return false;
        return true;
      });

      eligible.sort((a, b) => a.distMi - b.distMi);
      const keep = new Set(eligible.slice(0, MAX_LABELED_AIRCRAFT));

      for (const e of all) {
        e.labelWanted = keep.has(e);
        applyLabel(e);
      }
    }

    function repositionAllLabels() {
      for (const e of aircraftState.values()) {
        if (e.labelWanted) positionLabel(e);
      }
    }

    map.on("move zoom resize", () => repositionAllLabels());

    /**************************************************************
     * MAIN LOOP
     **************************************************************/
    let inFlight = false;

    async function fetchWithTimeout(url, timeoutMs) {
      const controller = new AbortController();
      const timer = setTimeout(() => controller.abort(), timeoutMs);
      try {
        return await fetch(url, { cache: "no-store", signal: controller.signal });
      } finally {
        clearTimeout(timer);
      }
    }

    async function tick() {
      if (inFlight) return;
      inFlight = true;

      const tickStart = performance.now();
      const nowMs = Date.now();

      try {
        setAirStatus("warn", "fetching");
        st.lastErr = null;
        st.lastErrDetail = null;

        const t0 = performance.now();
        const res = await fetchWithTimeout(airplanesLiveUrl(), FETCH_TIMEOUT_MS);
        const t1 = performance.now();
        st.lastLatencyMs = (t1 - t0);

        if (!res.ok) {
          st.lastErr = "HTTP";
          st.lastErrDetail = String(res.status);
          throw new Error(`HTTP ${res.status}`);
        }

        const raw = await res.json();
        const aircraft = normalizeAircraftList(raw);
        st.lastCount = aircraft.length;

        for (const ac of aircraft) upsertAircraft(ac, nowMs);

        pruneStale(nowMs);
        decideLabels();
        repositionAllLabels();

        st.lastOkMs = Date.now();
        setAirStatus("ok", "OK");

      } catch (e) {
        const name = (e && e.name) ? e.name : "Error";
        if (name === "AbortError") {
          setAirStatus("bad", "timeout");
          st.lastErr = "timeout";
          st.lastErrDetail = null;
        } else if (!st.lastErr) {
          setAirStatus("bad", "error");
          st.lastErr = "error";
          st.lastErrDetail = name;
        }
      } finally {
        st.lastTickDurMs = (performance.now() - tickStart);
        renderStatus();
        inFlight = false;
      }
    }

    renderStatus();
    tick();
    setInterval(tick, UPDATE_MS);
  </script>
</body>
</html>
